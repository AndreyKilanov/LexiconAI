# **Техническое задание (ТЗ) на разработку системы "LexiconAI"**

## **1\. Введение**

**Наименование проекта:** LexiconAI

**Цель проекта:** Создание мультиплатформенного сервиса (Web \+ Telegram) для лингвистического анализа слов с использованием искусственного интеллекта. Система предоставляет пользователю список синонимов и антонимов к заданному слову.

## **2\. Технологический стек**

* **Язык программирования:** Python 3.11+  
* **Web-фреймворк:** FastAPI (асинхронный)  
* **AI/LLM Оркестрация:** LangChain \+ LangGraph  
* **LLM Провайдер:** OpenAI (GPT-4o-mini)  
* **База данных:** PostgreSQL 15 (драйвер asyncpg, ORM SQLAlchemy)  
* **Telegram Бот:** aiogram 3.x  
* **Frontend:** HTML5, Jinja2, HTMX (для динамики без SPA), Tailwind CSS (стилизация)  
* **Инфраструктура:** Docker, Docker Compose, Nginx

## **3\. Архитектура системы**

Система построена по принципу модульного монолита с четким разделением слоев (Clean Architecture):

1. **Presentation Layer (Слой представления):**  
   * **Web UI:** Server-Side Rendering (SSR) шаблонов с динамическими вставками через HTMX.  
   * **REST API:** JSON-эндпоинты для внешних интеграций.  
   * **Telegram Bot:** Long-polling интерфейс для взаимодействия через мессенджер.  
2. **Application Layer (Слой приложения):**  
   * **Service Logic:** Бизнес-логика обработки запросов.  
   * **AI Service:** Граф обработки (LangGraph), отвечающий за генерацию и структурирование ответа от LLM.  
3. **Infrastructure Layer (Слой инфраструктуры):**  
   * **PostgreSQL:** Хранение истории запросов пользователей и кэширование словаря.  
   * **Nginx:** Обратный прокси-сервер для маршрутизации и статики.

## **4\. Функциональные требования**

### **4.1. AI Модуль (LangGraph)**

* **Вход:** Одно слово на естественном языке.  
* **Процесс:**  
  * Использование модели GPT-4o-mini (или аналогичной).  
  * Строгая типизация вывода (Structured Output) для гарантии JSON-формата.  
* **Выход:** Список из ровно 10 лексических единиц (приоритет: 5 синонимов, 5 антонимов).  
* **Атрибуты:** Для каждого слова указывается тип связи (synonym или antonym).

### **4.2. Веб-интерфейс**

* **Стиль:** Современный темный интерфейс (Dark Mode), напоминающий ChatGPT.  
* **Взаимодействие:**  
  * Поле ввода с кнопкой отправки.  
  * Отображение индикатора загрузки ("Печатает...").  
  * Добавление ответа в ленту чата без перезагрузки страницы (HTMX).  
* **Визуализация:** Цветовое кодирование результатов (зеленый для синонимов, красный для антонимов).

### **4.3. Telegram Бот**

* **Команды:** /start (приветствие).  
* **Обработка текста:** Любое текстовое сообщение воспринимается как запрос на анализ.  
* **Ответ:** Отформатированное сообщение с использованием emoji и Markdown.  
* **Интеграция:** Бот использует тот же сервисный слой и БД, что и веб\-сайт.

### **4.4. Хранение данных**

Система должна разделять логирование факта запроса и хранение самих лингвистических данных (кэширование).

**Таблица 1: request\_logs (История запросов)**

Хранит информацию о том, кто, когда и откуда сделал запрос.

* id (PK): Уникальный идентификатор лога.  
* user\_input: Слово, которое ввел пользователь.  
* source: Источник запроса (web, telegram, api).  
* created\_at: Дата и время запроса.

**Таблица 2: word\_dictionary (Лингвистические данные)**

Хранит уникальные слова и результаты их анализа. Это позволяет избежать повторных запросов к LLM для одних и тех же слов.

* word (PK/Unique): Исходное слово (нормализованное, в нижнем регистре).  
* associations (JSONB): Структурированный список из 10 элементов.  
  * **Формат данных внутри JSON:**  
    \[  
      {"word": "свет", "type": "antonym"},  
      {"word": "мрак", "type": "synonym"},  
      ...  
    \]

* updated\_at: Дата последнего обновления записи.

## **5\. API Спецификация**

### **POST /api/analyze**

Анализ слова через REST API.

**Request:**

{  
  "word": "счастье"  
}

**Response (200 OK):**

{  
  "original\_word": "счастье",  
  "results": \[  
    {"word": "радость", "relation\_type": "synonym"},  
    {"word": "горе", "relation\_type": "antonym"},  
    ...  
  \]  
}

## **6\. Требования к развертыванию (DevOps)**

* **Контейнеризация:** Все сервисы (app, db, nginx) описаны в docker-compose.yml.  
* **Среда:** Переменные окружения (API ключи, креды БД) передаются через .env.  
* **База данных:** Автоматическое создание таблиц при старте приложения (для MVP) или через миграции Alembic (для Production).  
* **Nginx:** Настроен как entry point на 80 порту, проксирует запросы на Uvicorn (порт 8000).

## **7\. Этапы приемки**

1. Успешный запуск docker-compose up \--build.  
2. Проверка работы веб\-чата: отправка слова \-\> получение списка без перезагрузки.  
3. Проверка Telegram бота: ответ на сообщение пользователя.  
4. Проверка БД:  
   * Наличие записи в request\_logs.  
   * Наличие (или обновление) записи в word\_dictionary с JSON-структурой синонимов/антонимов.